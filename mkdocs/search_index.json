{
    "docs": [
        {
            "location": "/", 
            "text": "Seismic.jl\n\n\nSeismic data processing, imaging and plotting\n\n\n\n\n\n\nOverview\n\n\nSeismic.jl provides tools to \nprocess\n, \nimage\n, and \nplot\n reflection seismic data in the Julia language.\n\n\n\n\nConvert data to a simple format\n\n\nData and headers are stored separately as \nfilename@data@\n and \nfilename@headers@\n for  simplicity. Functions are available to convert from popular formats such as SEGY, SU and RSF.\n\n\n\n\nManipulate data\n\n\nContains functions for geometry calculation, sorting, windowing, patching/un-patching, and processing keyed on header word.\n\n\n\n\nPlot publication quality figures\n\n\nProduce color and wiggle plots using PyPlot.jl\n\n\n\n\n\n\nInstallation\n\n\nTo install Seismic.jl type:\n\n\nPkg.add(\nSeismic\n)\n\n\n\n\n\nPkg.checkout(\nSeismic\n)\n\n\n\n\n\n\n\n\n\nGetting started\n\n\nTo start using the functions simply type \nusing Seismic\n. Below is a simple demonstration of the plotting functionality: \n\n\nusing PyPlot,Seismic\n\nparam = Dict(:nt=\n500, :nx1=\n500, :tau=\n[0.4, 1.0], :p1=\n[-.00003, 0.00008], :amp=\n[1., -0.5], :f0=\n20.0)\n\nd,ext = SeisLinearEvents(;param...)\n\nplotpar = Dict(:style=\noverlay\n,\n           :wiggle_trace_increment=\n10,\n           :xcur=\n0.8,\n           :aspect=\nauto\n,\n           :xlabel=\nX\n,:xunits=\nmeters\n,:ox=\n0,:dx=\n10,\n           :ylabel=\nTime\n,:yunits=\nseconds\n,:oy=\n0,:dy=\n0.004,\n           :wbox=\n8,:hbox=\n5,\n           :cmap=\nseismic\n);\n\nplotpar[:style]=\ncolor\n; plotpar[:title]=\ncolor\n; plotpar[:name]=\nplot1\n; \nSeisPlot(d;plotpar...);\nplotpar[:style]=\nwiggles\n; plotpar[:title]=\nwiggles\n; plotpar[:name]=\nplot2\n; \nSeisPlot(d;plotpar...);\nplotpar[:style]=\noverlay\n; plotpar[:title]=\noverlay\n; plotpar[:name]=\nplot3\n; \nSeisPlot(d;plotpar...);\n\n\n\n\n\nwill produce these three \n.eps\n files:", 
            "title": "Introduction"
        }, 
        {
            "location": "/#seismicjl", 
            "text": "Seismic data processing, imaging and plotting", 
            "title": "Seismic.jl"
        }, 
        {
            "location": "/#overview", 
            "text": "Seismic.jl provides tools to  process ,  image , and  plot  reflection seismic data in the Julia language.", 
            "title": "Overview"
        }, 
        {
            "location": "/#convert-data-to-a-simple-format", 
            "text": "Data and headers are stored separately as  filename@data@  and  filename@headers@  for  simplicity. Functions are available to convert from popular formats such as SEGY, SU and RSF.", 
            "title": "Convert data to a simple format"
        }, 
        {
            "location": "/#manipulate-data", 
            "text": "Contains functions for geometry calculation, sorting, windowing, patching/un-patching, and processing keyed on header word.", 
            "title": "Manipulate data"
        }, 
        {
            "location": "/#plot-publication-quality-figures", 
            "text": "Produce color and wiggle plots using PyPlot.jl", 
            "title": "Plot publication quality figures"
        }, 
        {
            "location": "/#installation", 
            "text": "To install Seismic.jl type:  Pkg.add( Seismic )  Pkg.checkout( Seismic )", 
            "title": "Installation"
        }, 
        {
            "location": "/#getting-started", 
            "text": "To start using the functions simply type  using Seismic . Below is a simple demonstration of the plotting functionality:   using PyPlot,Seismic\n\nparam = Dict(:nt= 500, :nx1= 500, :tau= [0.4, 1.0], :p1= [-.00003, 0.00008], :amp= [1., -0.5], :f0= 20.0)\n\nd,ext = SeisLinearEvents(;param...)\n\nplotpar = Dict(:style= overlay ,\n           :wiggle_trace_increment= 10,\n           :xcur= 0.8,\n           :aspect= auto ,\n           :xlabel= X ,:xunits= meters ,:ox= 0,:dx= 10,\n           :ylabel= Time ,:yunits= seconds ,:oy= 0,:dy= 0.004,\n           :wbox= 8,:hbox= 5,\n           :cmap= seismic );\n\nplotpar[:style]= color ; plotpar[:title]= color ; plotpar[:name]= plot1 ; \nSeisPlot(d;plotpar...);\nplotpar[:style]= wiggles ; plotpar[:title]= wiggles ; plotpar[:name]= plot2 ; \nSeisPlot(d;plotpar...);\nplotpar[:style]= overlay ; plotpar[:title]= overlay ; plotpar[:name]= plot3 ; \nSeisPlot(d;plotpar...);  will produce these three  .eps  files:", 
            "title": "Getting started"
        }, 
        {
            "location": "/Imaging/page1/", 
            "text": "Imaging\n\n\n\n\nPostStackWEM\n\n\nSeismic.PostStackWEM\n\n\n\n\n\n\n\nShotProfileEWEM\n\n\n#\n\n\nSeismic.ShotProfileEWEM\n \n \nFunction\n.\n\n\nShotProfileEWEM\n\n\nShot Profile Elastic Wave Equation Migration and Demigration of 3D isotropic data.\n\n\nIN\n\n\n\n\nm : vector of filenames of image (comprised of [mpp;mps1;mps2])\n\n\nd : vector of filenames of data (comprised of [ux;uy;uz])\n\n\nadj : flag for adjoint (migration), or forward (demigration) (default=true)\n\n\ndamping = 1000. : damping for deconvolution imaging condition\n\n\nvp = \"vp\" : seis file containing the p-wave velocity (should have same x and z dimensions as the desired image)\n\n\nvs = \"vs\" : seis file containing the s-wave velocity (should have same x and z dimensions as the desired image)\n\n\nangx = \"angx\" : seis file containing incidence angles in the x direction for each shot\n\n\nangy = \"angy\" : seis file containing incidence angles in the y direction for each shot\n\n\nwav = \"wav\" : seis file containing the source wavelet (in time domain)\n\n\nsz = 0. : source depth (Dev: read this from source wavelet file for variable source depth)\n\n\ngz = 0. : receiver depth (Dev: read this from data file for variable source depth (but then what to do in fwd op?))\n\n\nnangx = 1 : number of angle bins in x direction\n\n\noangx = 0. : min angle in x direction (angle between source incidence angle and reflector normal in Degrees)\n\n\ndangx = 1. : angle increment in x direction\n\n\nnangy = 1 : number of angle bins in y direction\n\n\noangy = 0. : min angle in y direction (angle between source incidence angle and reflector normal in Degrees)\n\n\ndangy = 1. : angle increment in y direction\n\n\nfmin = 0. : min frequency to process (Hz)\n\n\nfmax = 80. : max frequency to process (Hz)\n\n\npadt = 1 : pad factor for the time axis\n\n\npadx = 1 : pad factor for the spatial axes\n\n\nverbose = false : flag for error / debugging messages\n\n\nsx = [0.] : array of source X positions (meters)\n\n\nsy = [0.] : array of source Y positions (meters)\n\n\n\n\nOUT\n\n\nCredits: AS, 2015\n\n\nsource\n\n\n\n\nShotProfileWEM\n\n\n#\n\n\nSeismic.ShotProfileWEM\n \n \nFunction\n.\n\n\nShotProfileWEM\n\n\nShot Profile Wave Equation Migration and Demigration of 3D isotropic data.\n\n\nIN\n\n\n\n\nm : filename of image\n\n\nd : filename of data\n\n\nadj : flag for adjoint (migration), or forward (demigration) (default=true)\n\n\npspi : flag for Phase Shift Plus Interpolation (default=true)\n\n\nnref : number of reference velocities to use if pspi is selected (default=5)\n\n\nvel = \"vel\" : seis file containing the velocity (should have same x and z dimensions as the desired image)\n\n\nangx = \"angx\" : seis file containing incidence angles in the x direction for each shot\n\n\nangy = \"angy\" : seis file containing incidence angles in the y direction for each shot\n\n\nwav = \"wav\" : seis file containing the source wavelet (in time domain)\n\n\nsz = 0. : source depth (Dev: read this from source wavelet file for variable source depth)\n\n\ngz = 0. : receiver depth (Dev: read this from data file for variable source depth (but then what to do in fwd op?))\n\n\nnangx = 1 : number of angle bins in x direction\n\n\noangx = 0. : min angle in x direction (angle between source incidence angle and reflector normal in Degrees)\n\n\ndangx = 1. : angle increment in x direction\n\n\nnangy = 1 : number of angle bins in y direction\n\n\noangy = 0. : min angle in y direction (angle between source incidence angle and reflector normal in Degrees)\n\n\ndangy = 1. : angle increment in y direction\n\n\nfmin = 0. : min frequency to process (Hz)\n\n\nfmax = 80. : max frequency to process (Hz)\n\n\npadt = 2 : pad factor for the time axis\n\n\npadx = 2 : pad factor for the spatial axes\n\n\nverbose = false : flag for error / debugging messages\n\n\nsx = [0.] : array of source X positions (meters)\n\n\nsy = [0.] : array of source Y positions (meters)\n\n\n\n\nOUT\n\n\nCredits: AS, 2015\n\n\nsource\n\n\n\n\nComputeAngles\n\n\n#\n\n\nSeismic.ComputeAngles\n \n \nFunction\n.\n\n\nComputeAngles\n\n\nCompute angles for shot gathers. These angles can be used for mapping migrated shots into angle gathers during shot profile migration.\n\n\nIN\n\n\n\n\nangx = \"angx\" : filename for incidence angles in the x direction for each shot\n\n\nangy = \"angy\" : filename for incidence angles in the y direction for each shot\n\n\ndip_flag = false : flag to subtract reflector dip from the computed angles to make them with reference to reflector normal\n\n\nvel = \"vel\" : seis file containing the velocity (should have same x and z dimensions as the desired image)\n\n\nwav = \"wav\" : seis file containing the source wavelet (in time domain)\n\n\nsz = 0. : source depth (Dev: read this from source wavelet file for variable source depth)\n\n\nnhx = 101 : number of offset bins\n\n\nohx = 1000. : min offset (surface offset in the data)\n\n\ndhx = 10. : offset increment\n\n\nnhy = 101 : number of offset bins\n\n\nohy = 1000. : min offset (surface offset in the data)\n\n\ndhy = 10. : offset increment\n\n\npade_flag = false : flag for Pade Fourier correction\n\n\nfmin = 0. : min frequency to process (Hz)\n\n\nfmax = 80. : max frequency to process (Hz)\n\n\npadt = 2 : pad factor for the time axis\n\n\npadx = 2 : pad factor for the spatial axes\n\n\nverbose = false : flag for error / debugging messages\n\n\nsx = [0.] : array of source X positions (meters)\n\n\nsy = [0.] : array of source Y positions (meters)\n\n\n\n\nOUT\n\n\nCredits: AS, 2015\n\n\nsource", 
            "title": "Imaging"
        }, 
        {
            "location": "/Imaging/page1/#imaging", 
            "text": "", 
            "title": "Imaging"
        }, 
        {
            "location": "/Imaging/page1/#poststackwem", 
            "text": "Seismic.PostStackWEM", 
            "title": "PostStackWEM"
        }, 
        {
            "location": "/Imaging/page1/#shotprofileewem", 
            "text": "#  Seismic.ShotProfileEWEM     Function .  ShotProfileEWEM  Shot Profile Elastic Wave Equation Migration and Demigration of 3D isotropic data.  IN   m : vector of filenames of image (comprised of [mpp;mps1;mps2])  d : vector of filenames of data (comprised of [ux;uy;uz])  adj : flag for adjoint (migration), or forward (demigration) (default=true)  damping = 1000. : damping for deconvolution imaging condition  vp = \"vp\" : seis file containing the p-wave velocity (should have same x and z dimensions as the desired image)  vs = \"vs\" : seis file containing the s-wave velocity (should have same x and z dimensions as the desired image)  angx = \"angx\" : seis file containing incidence angles in the x direction for each shot  angy = \"angy\" : seis file containing incidence angles in the y direction for each shot  wav = \"wav\" : seis file containing the source wavelet (in time domain)  sz = 0. : source depth (Dev: read this from source wavelet file for variable source depth)  gz = 0. : receiver depth (Dev: read this from data file for variable source depth (but then what to do in fwd op?))  nangx = 1 : number of angle bins in x direction  oangx = 0. : min angle in x direction (angle between source incidence angle and reflector normal in Degrees)  dangx = 1. : angle increment in x direction  nangy = 1 : number of angle bins in y direction  oangy = 0. : min angle in y direction (angle between source incidence angle and reflector normal in Degrees)  dangy = 1. : angle increment in y direction  fmin = 0. : min frequency to process (Hz)  fmax = 80. : max frequency to process (Hz)  padt = 1 : pad factor for the time axis  padx = 1 : pad factor for the spatial axes  verbose = false : flag for error / debugging messages  sx = [0.] : array of source X positions (meters)  sy = [0.] : array of source Y positions (meters)   OUT  Credits: AS, 2015  source", 
            "title": "ShotProfileEWEM"
        }, 
        {
            "location": "/Imaging/page1/#shotprofilewem", 
            "text": "#  Seismic.ShotProfileWEM     Function .  ShotProfileWEM  Shot Profile Wave Equation Migration and Demigration of 3D isotropic data.  IN   m : filename of image  d : filename of data  adj : flag for adjoint (migration), or forward (demigration) (default=true)  pspi : flag for Phase Shift Plus Interpolation (default=true)  nref : number of reference velocities to use if pspi is selected (default=5)  vel = \"vel\" : seis file containing the velocity (should have same x and z dimensions as the desired image)  angx = \"angx\" : seis file containing incidence angles in the x direction for each shot  angy = \"angy\" : seis file containing incidence angles in the y direction for each shot  wav = \"wav\" : seis file containing the source wavelet (in time domain)  sz = 0. : source depth (Dev: read this from source wavelet file for variable source depth)  gz = 0. : receiver depth (Dev: read this from data file for variable source depth (but then what to do in fwd op?))  nangx = 1 : number of angle bins in x direction  oangx = 0. : min angle in x direction (angle between source incidence angle and reflector normal in Degrees)  dangx = 1. : angle increment in x direction  nangy = 1 : number of angle bins in y direction  oangy = 0. : min angle in y direction (angle between source incidence angle and reflector normal in Degrees)  dangy = 1. : angle increment in y direction  fmin = 0. : min frequency to process (Hz)  fmax = 80. : max frequency to process (Hz)  padt = 2 : pad factor for the time axis  padx = 2 : pad factor for the spatial axes  verbose = false : flag for error / debugging messages  sx = [0.] : array of source X positions (meters)  sy = [0.] : array of source Y positions (meters)   OUT  Credits: AS, 2015  source", 
            "title": "ShotProfileWEM"
        }, 
        {
            "location": "/Imaging/page1/#computeangles", 
            "text": "#  Seismic.ComputeAngles     Function .  ComputeAngles  Compute angles for shot gathers. These angles can be used for mapping migrated shots into angle gathers during shot profile migration.  IN   angx = \"angx\" : filename for incidence angles in the x direction for each shot  angy = \"angy\" : filename for incidence angles in the y direction for each shot  dip_flag = false : flag to subtract reflector dip from the computed angles to make them with reference to reflector normal  vel = \"vel\" : seis file containing the velocity (should have same x and z dimensions as the desired image)  wav = \"wav\" : seis file containing the source wavelet (in time domain)  sz = 0. : source depth (Dev: read this from source wavelet file for variable source depth)  nhx = 101 : number of offset bins  ohx = 1000. : min offset (surface offset in the data)  dhx = 10. : offset increment  nhy = 101 : number of offset bins  ohy = 1000. : min offset (surface offset in the data)  dhy = 10. : offset increment  pade_flag = false : flag for Pade Fourier correction  fmin = 0. : min frequency to process (Hz)  fmax = 80. : max frequency to process (Hz)  padt = 2 : pad factor for the time axis  padx = 2 : pad factor for the spatial axes  verbose = false : flag for error / debugging messages  sx = [0.] : array of source X positions (meters)  sy = [0.] : array of source Y positions (meters)   OUT  Credits: AS, 2015  source", 
            "title": "ComputeAngles"
        }, 
        {
            "location": "/Modelling/page1/", 
            "text": "Modelling\n\n\nSeismic.jl provides various ways to generate synthetic data set, like multi-dimensional linear, parabola, hyperbola events and finite-difference solver for acoustic wave equation (Currently only 2D is supported)\n\n\n\n\nSeisLinearEvents\n\n\n#\n\n\nSeismic.SeisLinearEvents\n \n \nFunction\n.\n\n\nSeisLinearEvents(; \nkeyword arguments\n)\n\n\n\n\n\nGenerate five dimensional data \nd\n consisting of linear events.\n\n\nArguments\n\n\nKeyword arguments\n\n\n\n\not=0.0\n: first sample for the time axis in secs.\n\n\ndt=0.004\n: sampling interval in secs.\n\n\nnt=500\n: number of time samples.\n\n\nox1=0.0\n: first sample for the first spatial dimension in meters.\n\n\ndx1=10.0\n: sample interval for the first spatial dimension in meters.\n\n\nnx1=100\n: number of samples for the first spatial dimension.\n\n\nox2=0.0\n: first sample for the second spatial dimension in meters.\n\n\ndx2=10.0\n: sample interval for the second spatial dimension in meters.\n\n\nnx2=1\n: number of samples for the second spatial dimension.\n\n\nox3=0.0\n: second sample for the third spatial dimension in meters.\n\n\ndx3=10.0\n: sample interval for the third spatial dimension in meters.\n\n\nnx3=1\n: number of samples for the third spatial dimension.\n\n\nox4=0.0\n: third sample for the fourth spatial dimension in meters.\n\n\ndx4=10.0\n: sample interval for the fourth spatial dimension in meters.\n\n\nnx4=1\n:number of samples for the fourth spatial dimension.\n\n\ntau=[1.0, 1.6]\n: intercept traveltimes for each event.\n\n\np1=[0.0000,-0.0001]\n\n\np2=[0.0003, 0.0002]\n\n\np3=[-0.0001,-0.0001]\n\n\np4=[0.0001,-0.0000]\n\n\namp=[1.0,-1.0]\n: amplitudes for each linear event.\n\n\nf0=20.0\n: central frequency of wavelet for each linear event.\n\n\n\n\nExample\n\n\njulia\n \nd\n,\nextent\n \n=\n \nSeisLinearEvents\n();\n \nSeisPlot\n(\nd\n);\n\n\n\n\n\n\nCredits: Aaron Stanton, 2015\n\n\nsource\n\n\n\n\nSeisParabEvents\n\n\n#\n\n\nSeismic.SeisParabEvents\n \n \nFunction\n.\n\n\nSeisParabEvents(; \nkeyword arguments\n)\n\n\n\n\n\nGenerate five dimensional data \nd\n consisting of parabolic events.\n\n\nArguments\n\n\nKeyword arguments\n\n\n\n\not=0.0\n: first sample for the time axis in secs.\n\n\ndt=0.004\n: sampling interval in secs.\n\n\nnt=500\n: number of time samples.\n\n\nox1=0.0\n: first sample for the first spatial dimension in meters.\n\n\ndx1=10.0\n: sample interval for the first spatial dimension in meters.\n\n\nnx1=100\n: number of samples for the first spatial dimension.\n\n\nox2=0.0\n: first sample for the second spatial dimension in meters.\n\n\ndx2=10.0\n: sample interval for the second spatial dimension in meters.\n\n\nnx2=1\n: number of samples for the second spatial dimension.\n\n\nox3=0.0\n: second sample for the third spatial dimension in meters.\n\n\ndx3=10.0\n: sample interval for the third spatial dimension in meters.\n\n\nnx3=1\n: number of samples for the third spatial dimension.\n\n\nox4=0.0\n: third sample for the fourth spatial dimension in meters.\n\n\ndx4=10.0\n: sample interval for the fourth spatial dimension in meters.\n\n\nnx4=1\n:number of samples for the fourth spatial dimension.\n\n\ntau=[1.0, 1.6]\n: intercept traveltimes for each event.\n\n\n`p1=[0.0000,-0.0001]\n\n\n`p2=[0.0003, 0.0002]\n\n\n`p3=[-0.0001,-0.0001]\n\n\n`p4=[0.0001,-0.0000]\n\n\namp=[1.0,-1.0]\n: amplitudes for each parabolic event.\n\n\nwavelet=\"ricker\"\n: wavelet used to model the parabolicr events.\n\n\nf0=[20.0]\n: central frequency of wavelet for each parabolic event.\n\n\n\n\nExample\n\n\njulia\n \nd\n,\n \nextent\n \n=\n \nSeisParabEvents\n();\n \nSeisPlot\n(\nd\n);\n\n\n\n\n\n\nCredits: Mauricio D Sacchi, 2015\n\n\nsource\n\n\n\n\nSeisHypEvents\n\n\n#\n\n\nSeismic.SeisHypEvents\n \n \nFunction\n.\n\n\nSeisHypEvents(; \n)\n\n\nGenerate two dimensional data \nd\n consisting of hyperbolic events.\n\n\nKeyword arguments\n\n\n\n\not::Real=0.0\n: first sample for the time axis in secs.\n\n\ndt::Real=0.004\n: sampling interval in secs.\n\n\nnt::Int=301\n: number of time samples.\n\n\nox::Real=-1000.0\n: first sample for spatial dimension in meters.\n\n\ndx::Real=20.0\n: sample interval for the spatial dimension in meters.\n\n\nnx::Int=101\n: number of samples for the spatial dimension.\n\n\ntau::Vector{Real}=[0.2, 0.6, 0.9]\n: intercept traveltimes for each event.\n\n\nvel::Vector{Real}=[1500.0, 2000.0, 3000.0]\n: rms velocities in m/s\n\n\napex::Vector{Real}=[0.0, 0.0, 0.0]\n: apex-shifts in meters.\n\n\namp::Vector{Real}=[1.0, -1.0, 1.0]\n: amplitudes for each event.\n\n\nwavelet::AbstractString=\"ricker\"\n: wavelet used to model the events.\n\n\nf0::Vector{Real}=[20.0]\n: central frequency of wavelet for each event.\n\n\n\n\nOutput\n\n\n\n\nd::Array{Real, 2}\n: two dimensional data consisting of hyperbolic events.\n\n\nextent::Extent\n: extent of the data \nd\n.\n\n\n\n\nExamples\n\n\njulia\n \nd\n,\n \nextent\n \n=\n \nSeisHypEvents\n();\n \nSeisPlot\n(\nd\n,\n \nextent\n);\n\n\njulia\n \nd\n,\n \nextent\n \n=\n \nSeisHypEvents\n(\napex\n=\n[\n100\n,\n \n200\n,\n \n-\n300\n],\n \nf0\n=\n[\n30\n,\n \n20\n,\n \n15\n]);\n\n\nSeisPlot\n(\nd\n,\n \nextent\n);\n\n\n\n\n\n\nsource\n\n\n\n\nSeisAddNoise\n\n\n#\n\n\nSeismic.SeisAddNoise\n \n \nFunction\n.\n\n\nSeisAddNoise(d, snr; \nkeyword arguments\n)\n\n\n\n\n\nAdd noise at a given signal-to-noise ratio level \nsnr\n to an N-dimensional input data \nd\n. Noise can be band limited using kewyord \nL\n.\n\n\nArguments\n\n\n\n\nd::Array{Real, N}\n: N-dimensional data.\n\n\nsnr::Real\n: signal-to-noise ratio.\n\n\n\n\nKeyword arguments\n\n\n\n\ndb::Bool=false\n: \ndb=false\n if \nsnr\n is given by amplitude, \ndb=true\n if\n\n\n\n\nsnr is given in dB.\n\n\n\n\npdf::AbstractString=\"gaussian\"\n: random noise probability distribution:\n\n\n\n\n\"gaussian\"\n or \n\"uniform\"\n.\n\n\n\n\nL::Int=1\n: averaging operator length to band-limit the random noise.\n\n\n\n\nExamples\n\n\njulia\n \nw\n \n=\n \nRicker\n();\n \nwn\n \n=\n \nSeisAddNoise\n(\nw\n,\n \n2\n);\n \nplot\n(\nw\n);\n \nplot\n(\nwn\n);\n\n\nMeasureSNR\n(\nw\n,\n \nwn\n)\n\n\n\njulia\n \nd\n,\n \nextent\n \n=\n \nSeisHypEvents\n();\n \ndn\n \n=\n \nSeisAddNoise\n(\nd\n,\n \n1.0\n,\n \ndb\n=\ntrue\n,\n \nL\n=\n9\n);\n\n\nSeisPlot\n([\nd\n \ndn\n],\n \nextent\n);\n \nMeasureSNR\n(\nd\n,\n \ndn\n,\n \ndb\n=\ntrue\n)\n\n\n\n\n\n\nCredits: Juan I. Sabbione, 2016\n\n\nsource\n\n\n\n\nSeisAcousticWave\n\n\n#\n\n\nSeismic.SeisAcousticWave\n \n \nFunction\n.\n\n\nshot = SeisAcousticWave(fidMtx, pos, isz, isx, f0, dt, tmax=2.0)\n\n\n\n\n\nfinite difference modeling of acoustic wave field, generate a common shot gather\n\n\nArguments\n\n\n\n\nfidMtx :: FidMtx\n        : composite type of sparse matrix\n\n\npos    :: Array{Int64,2}\n: index of receivers, first column is the vertical index, second column contains horizontal index.\n\n\nisz    :: Int64\n         : vertical index of source\n\n\nisz    :: Int64\n         : horizontal index of source\n\n\nf0     :: Float64\n       : dominant frequency of Ricker wavelet\n\n\ndt     :: Float64\n       : size of time step\n\n\n\n\nkeywords Arguments\n\n\n\n\ntmax=1.0\n : length of simulation\n\n\n\n\nOutput\n\n\n\n\nshot :: ShotGather\n: composite type for common shot gather\n\n\n\n\nsource", 
            "title": "Modelling"
        }, 
        {
            "location": "/Modelling/page1/#modelling", 
            "text": "Seismic.jl provides various ways to generate synthetic data set, like multi-dimensional linear, parabola, hyperbola events and finite-difference solver for acoustic wave equation (Currently only 2D is supported)", 
            "title": "Modelling"
        }, 
        {
            "location": "/Modelling/page1/#seislinearevents", 
            "text": "#  Seismic.SeisLinearEvents     Function .  SeisLinearEvents(;  keyword arguments )  Generate five dimensional data  d  consisting of linear events.  Arguments  Keyword arguments   ot=0.0 : first sample for the time axis in secs.  dt=0.004 : sampling interval in secs.  nt=500 : number of time samples.  ox1=0.0 : first sample for the first spatial dimension in meters.  dx1=10.0 : sample interval for the first spatial dimension in meters.  nx1=100 : number of samples for the first spatial dimension.  ox2=0.0 : first sample for the second spatial dimension in meters.  dx2=10.0 : sample interval for the second spatial dimension in meters.  nx2=1 : number of samples for the second spatial dimension.  ox3=0.0 : second sample for the third spatial dimension in meters.  dx3=10.0 : sample interval for the third spatial dimension in meters.  nx3=1 : number of samples for the third spatial dimension.  ox4=0.0 : third sample for the fourth spatial dimension in meters.  dx4=10.0 : sample interval for the fourth spatial dimension in meters.  nx4=1 :number of samples for the fourth spatial dimension.  tau=[1.0, 1.6] : intercept traveltimes for each event.  p1=[0.0000,-0.0001]  p2=[0.0003, 0.0002]  p3=[-0.0001,-0.0001]  p4=[0.0001,-0.0000]  amp=[1.0,-1.0] : amplitudes for each linear event.  f0=20.0 : central frequency of wavelet for each linear event.   Example  julia   d , extent   =   SeisLinearEvents ();   SeisPlot ( d );   Credits: Aaron Stanton, 2015  source", 
            "title": "SeisLinearEvents"
        }, 
        {
            "location": "/Modelling/page1/#seisparabevents", 
            "text": "#  Seismic.SeisParabEvents     Function .  SeisParabEvents(;  keyword arguments )  Generate five dimensional data  d  consisting of parabolic events.  Arguments  Keyword arguments   ot=0.0 : first sample for the time axis in secs.  dt=0.004 : sampling interval in secs.  nt=500 : number of time samples.  ox1=0.0 : first sample for the first spatial dimension in meters.  dx1=10.0 : sample interval for the first spatial dimension in meters.  nx1=100 : number of samples for the first spatial dimension.  ox2=0.0 : first sample for the second spatial dimension in meters.  dx2=10.0 : sample interval for the second spatial dimension in meters.  nx2=1 : number of samples for the second spatial dimension.  ox3=0.0 : second sample for the third spatial dimension in meters.  dx3=10.0 : sample interval for the third spatial dimension in meters.  nx3=1 : number of samples for the third spatial dimension.  ox4=0.0 : third sample for the fourth spatial dimension in meters.  dx4=10.0 : sample interval for the fourth spatial dimension in meters.  nx4=1 :number of samples for the fourth spatial dimension.  tau=[1.0, 1.6] : intercept traveltimes for each event.  `p1=[0.0000,-0.0001]  `p2=[0.0003, 0.0002]  `p3=[-0.0001,-0.0001]  `p4=[0.0001,-0.0000]  amp=[1.0,-1.0] : amplitudes for each parabolic event.  wavelet=\"ricker\" : wavelet used to model the parabolicr events.  f0=[20.0] : central frequency of wavelet for each parabolic event.   Example  julia   d ,   extent   =   SeisParabEvents ();   SeisPlot ( d );   Credits: Mauricio D Sacchi, 2015  source", 
            "title": "SeisParabEvents"
        }, 
        {
            "location": "/Modelling/page1/#seishypevents", 
            "text": "#  Seismic.SeisHypEvents     Function .  SeisHypEvents(;  )  Generate two dimensional data  d  consisting of hyperbolic events.  Keyword arguments   ot::Real=0.0 : first sample for the time axis in secs.  dt::Real=0.004 : sampling interval in secs.  nt::Int=301 : number of time samples.  ox::Real=-1000.0 : first sample for spatial dimension in meters.  dx::Real=20.0 : sample interval for the spatial dimension in meters.  nx::Int=101 : number of samples for the spatial dimension.  tau::Vector{Real}=[0.2, 0.6, 0.9] : intercept traveltimes for each event.  vel::Vector{Real}=[1500.0, 2000.0, 3000.0] : rms velocities in m/s  apex::Vector{Real}=[0.0, 0.0, 0.0] : apex-shifts in meters.  amp::Vector{Real}=[1.0, -1.0, 1.0] : amplitudes for each event.  wavelet::AbstractString=\"ricker\" : wavelet used to model the events.  f0::Vector{Real}=[20.0] : central frequency of wavelet for each event.   Output   d::Array{Real, 2} : two dimensional data consisting of hyperbolic events.  extent::Extent : extent of the data  d .   Examples  julia   d ,   extent   =   SeisHypEvents ();   SeisPlot ( d ,   extent );  julia   d ,   extent   =   SeisHypEvents ( apex = [ 100 ,   200 ,   - 300 ],   f0 = [ 30 ,   20 ,   15 ]);  SeisPlot ( d ,   extent );   source", 
            "title": "SeisHypEvents"
        }, 
        {
            "location": "/Modelling/page1/#seisaddnoise", 
            "text": "#  Seismic.SeisAddNoise     Function .  SeisAddNoise(d, snr;  keyword arguments )  Add noise at a given signal-to-noise ratio level  snr  to an N-dimensional input data  d . Noise can be band limited using kewyord  L .  Arguments   d::Array{Real, N} : N-dimensional data.  snr::Real : signal-to-noise ratio.   Keyword arguments   db::Bool=false :  db=false  if  snr  is given by amplitude,  db=true  if   snr is given in dB.   pdf::AbstractString=\"gaussian\" : random noise probability distribution:   \"gaussian\"  or  \"uniform\" .   L::Int=1 : averaging operator length to band-limit the random noise.   Examples  julia   w   =   Ricker ();   wn   =   SeisAddNoise ( w ,   2 );   plot ( w );   plot ( wn );  MeasureSNR ( w ,   wn )  julia   d ,   extent   =   SeisHypEvents ();   dn   =   SeisAddNoise ( d ,   1.0 ,   db = true ,   L = 9 );  SeisPlot ([ d   dn ],   extent );   MeasureSNR ( d ,   dn ,   db = true )   Credits: Juan I. Sabbione, 2016  source", 
            "title": "SeisAddNoise"
        }, 
        {
            "location": "/Modelling/page1/#seisacousticwave", 
            "text": "#  Seismic.SeisAcousticWave     Function .  shot = SeisAcousticWave(fidMtx, pos, isz, isx, f0, dt, tmax=2.0)  finite difference modeling of acoustic wave field, generate a common shot gather  Arguments   fidMtx :: FidMtx         : composite type of sparse matrix  pos    :: Array{Int64,2} : index of receivers, first column is the vertical index, second column contains horizontal index.  isz    :: Int64          : vertical index of source  isz    :: Int64          : horizontal index of source  f0     :: Float64        : dominant frequency of Ricker wavelet  dt     :: Float64        : size of time step   keywords Arguments   tmax=1.0  : length of simulation   Output   shot :: ShotGather : composite type for common shot gather   source", 
            "title": "SeisAcousticWave"
        }, 
        {
            "location": "/Operators/page1/", 
            "text": "Operators", 
            "title": "Operators"
        }, 
        {
            "location": "/Operators/page1/#operators", 
            "text": "", 
            "title": "Operators"
        }, 
        {
            "location": "/Plotting/page1/", 
            "text": "Plotting\n\n\nTools for figure plotting\n\n\n\n\nSeisPlot\n\n\nSeismic.SeisPlot\n\n\n\n\n\n\n\nSeisPlotCoordinates\n\n\nSeismic.SeisPlotCoordinates", 
            "title": "Plotting"
        }, 
        {
            "location": "/Plotting/page1/#plotting", 
            "text": "Tools for figure plotting", 
            "title": "Plotting"
        }, 
        {
            "location": "/Plotting/page1/#seisplot", 
            "text": "Seismic.SeisPlot", 
            "title": "SeisPlot"
        }, 
        {
            "location": "/Plotting/page1/#seisplotcoordinates", 
            "text": "Seismic.SeisPlotCoordinates", 
            "title": "SeisPlotCoordinates"
        }, 
        {
            "location": "/Processing/page1/", 
            "text": "Processing\n\n\n\n\nSeisBandPass\n\n\n#\n\n\nSeismic.SeisBandPass\n \n \nFunction\n.\n\n\nSeisBandPass(d ; \nkeyword arguments\n)\n\n\n\n\n\nApply a bandpass filter to a 2D array input. Input and output data is in tx domain. Filter is applied in fx domain.\n\n\nArguments\n\n\n\n\nd\n: Input 2D data array in tx domain.\n\n\n\n\nKeyword arguments\n\n\n\n\ndt=0.001\n: time sampling interval.\n\n\nfa=0,fb=0,fc=60,fd=80\n: corner frequencies in Hz.\n\n\n\n\nOutput\n\n\n\n\nd\n: Filtered 2d data arrayn in tx domain.\n\n\n\n\nExample\n\n\n```julia julia\n d = SeisLinearEvents(d); SeisPlot(d,plot_type=\"Amplitude\",dy=0.004,fmax=125); julia\n d_filter = SeisBandPass(d;dt=0.004,fc=15,fd=35); SeisPlot(d_filter,plot_type=\"Amplitude\",dy=0.004,fmax=125);\n\n\nsource\n\n\n\n\nSeisDecimate\n\n\n#\n\n\nSeismic.SeisDecimate\n \n \nFunction\n.\n\n\nSeisDecimate(d ; \nkeyword arguments\n)\n\n\n\n\n\nDecimate a multidimensional array input. Input and output have the same dimension\n\n\nArguments\n\n\n\n\nd\n: Input data. Between 2D and 5D\n\n\n\n\nKeyword arguments\n\n\n\n\nmode=random\n: Data is decimated randomly. Otherwise it is regularly decimated.\n\n\nperc=50\n: percentage of traces to be decimated from original array\n\n\nincx1=1,incx2=1,incx3=1,incx4=1\n: traces to decimate in case of regular decimation\n\n\n\n\nOutput\n\n\n\n\nout\n: Decimated data.\n\n\n\n\nExample\n\n\n```julia julia\n d = SeisLinearEvents(d); SeisPlot(d) julia\n d_dec = SeisDecimate(d); SeisPlot(d_dec)\n\n\nsource\n\n\n\n\nSeisDelay\n\n\n#\n\n\nSeismic.SeisDelay\n \n \nFunction\n.\n\n\nSeisDelay(d ; \nkeyword arguments\n)\n\n\n\n\n\nApply a time delay to a 2D array input. \n\n\nArguments\n\n\n\n\nd\n: Input 2D data array in tx domain.\n\n\n\n\nKeyword arguments\n\n\n\n\ndelay=0.1\n: time delay in seconds.\n\n\ndt=0.001\n: time sampling\n\n\n\n\nOutput\n\n\n\n\nd2\n: Delayed data in time domain\n\n\n\n\nExample\n\n\n```julia julia\n d = SeisLinearEvents(d); SeisPlot(d); julia\n d2 = SeisDelay(d;dt=0.004); SeisPlot(d);\n\n\nsource\n\n\n\n\nSeisEnvelope\n\n\n#\n\n\nSeismic.SeisEnvelope\n \n \nFunction\n.\n\n\nSeisEnvelope(d)\n\n\n\n\n\nCalculate the envelope attribute of an input trace\n\n\nArguments\n\n\n\n\nd\n: Input data.\n\n\n\n\nOutput\n\n\n\n\nout\n: Envelope of input data\n\n\n\n\nExample\n\n\n```julia julia\n d = SeisLinearEvents(d); SeisPlot(d) julia\n out = SeisEnvelope(d); SeisPlot(d_dec)\n\n\nsource\n\n\n\n\nSeisFKFilter\n\n\n#\n\n\nSeismic.SeisFKFilter\n \n \nFunction\n.\n\n\nSeisFKFilter(d ; \nkeyword arguments\n)\n\n\n\n\n\nDecimate a multidimensional array input. Input and output have the same dimension\n\n\nArguments\n\n\n\n\nd\n: 2D Input data.\n\n\n\n\nKeyword arguments\n\n\n\n\ndt=0.002\n: time sampling interval.\n\n\ndx=10\n: space sampling interval.\n\n\nva=-2000,vb=-3000,vc=3000,vd=2000\n: corner velocities to be filtered\n\n\n\n\nOutput\n\n\n\n\nout\n: Filtered data.\n\n\n\n\nsource\n\n\n\n\nSeisGain\n\n\n#\n\n\nSeismic.SeisGain\n \n \nFunction\n.\n\n\nSeisGain(d, t; \nkeyword arguments\n)\n\n\n\n\n\nGain a group of traces.\n\n\nArguments\n\n\n\n\nd::Array{Real,2}\n: two dimensional data.\n\n\n\n\nKeyword arguments\n\n\n\n\ndt::Real=0.002\n: sampling interval in secs.\n\n\nkind::AbstractString=\"time\"\n: if kind=\"time\", gain = t.^a . * exp(-bt);                        if kind=\"agc\", automatic gain control is applied.\n\n\nparam::Vector{Real}=[2.0,0.0]\n: if kind=\"time\", param = [a,b];                                  if kind=\"agc\", param = [agc_gate]\n\n\nnorm::Int=0\n: \nnorm=0\n no normalization; \nnorm=1\n normalize each trace by                 amplitude; \nnorm=2\n normalize each trace by rms value/\n\n\n\n\nOutput\n\n\n\n\nd::Array{Real, 2}`: gained two dimensional data.\n\n\n\n\nExample\n\n\njulia\n \nd\n,\n \nextent\n \n=\n \nSeisHypEvents\n();\n\n       \ndout\n \n=\n \nSeisGain\n(\nd\n,\n \nkind\n=\nagc\n,\n \nparam\n=\n[\n0.05\n]);\n\n       \nSeisPlot\n([\nd\n \ndout\n],\n \nextent\n);\n\n\n\n\n\n\nCredits: Juan I. Sabbione, Aaron Staton, Mauricio D. Sacchi, 2016\n\n\nsource\n\n\n\n\nSeisKolmogoroff\n\n\n#\n\n\nSeismic.SeisKolmogoroff\n \n \nFunction\n.\n\n\nSeisKolmogoroff(w)\n\n\n\n\n\nKolmogoroff factorization. Transform a wavelet into its minimum phase equivalent.\n\n\nArguments\n\n\n\n\nw::Real\n: input wavelet.\n\n\n\n\nExample\n\n\njulia\n \nw\n \n=\n \nRicker\n()\n\n\njulia\n \nwmin\n \n=\n \nSeisKolmogoroff\n(\nw\n)\n\n\njulia\n \nplot\n(\nw\n);\n \nplot\n(\nwmin\n)\n\n\n\n\n\n\nReference\n\n\n\n\nClaerbout, Jon F., 1976, Fundamentals of geophysical data processing.\n\n\n\n\nMcGraw-Hill Inc.\n\n\nsource\n\n\n\n\nSeisMWNI\n\n\n#\n\n\nSeismic.SeisMWNI\n \n \nFunction\n.\n\n\nSeisMWNI\n\n\nMinimum Weighted Norm Interpolation of seismic records.\n\n\nIN\n   \n\n\n\n\nd_in: input data that can have up to 5 dimensions\n\n\ndt=0.001 sampling rate along the time axis (in seconds)\n\n\nfmax=99999. maximum temporal frequency to process.\n\n\npadt=2 padding to use for the time axis\n\n\npadx=1 padding to use for the spatial axes\n\n\nNiter_internal=10 number of internal iterations for Conjugate Gradients\n\n\nNiter_external=3 number of external iterations for iterative reweighting\n\n\n\n\nOUT\n  \n\n\n\n\nd_out: interpolated data\n\n\n\n\nsource\n\n\n\n\nSeisPOCS\n\n\n#\n\n\nSeismic.SeisPOCS\n \n \nFunction\n.\n\n\nSeisPOCS\n\n\nProjection Onto Convex Sets interpolation of seismic records.\n\n\nIN\n\n\n\n\nd_in: input data that can have up to 5 dimensions\n\n\np=1., exponent for thresholding (1 is equivalent to soft thres. high number is equivalent to hard thresholding)\n\n\nalpha=1 add-back ratio for imputation step. Use 1 for noise free data, and \n 1 for denoising of original traces.\n\n\ndt=0.001 sampling rate along the time axis (in seconds)\n\n\nfmax=99999. maximum temporal frequency to process.\n\n\npadt=2 padding to use for the time axis\n\n\npadx=1 padding to use for the spatial axes\n\n\nNiter=100 number of iterations\n\n\n\n\nOUT\n\n\n\n\nd_out: interpolated data\n\n\n\n\nsource\n\n\n\n\nSeisRadonFreqFor\n\n\n#\n\n\nSeismic.SeisRadonFreqFor\n \n \nFunction\n.\n\n\nSeisRadonFreqFor(m, nt; \nkeyword arguments\n)\n\n\n\n\n\nTransform a tau-p gather to a time-offset gather using a frequency domain forward parabolic or linear Radon operator.\n\n\nArguments\n\n\n\n\nm::Array{T\n:Real,2}\n: 2D Radon panel, \nm[1:ntau,1:np]\n, where \nntau\n is the\n\n\n\n\nnumber of intercept times and \nnp\n the number of curvatures or ray parameters.\n\n\n\n\nnt::Int\n: number of time samples in the data domain.\n\n\n\n\nKeyword arguments\n\n\n\n\norder::AbstractString=\"parab\"\n: \n\"parab\"\n for parabolic transform, \n\"linear\"\n\n\n\n\nfor linear transform.\n\n\n\n\ndt::Real=0.004\n: sampling interval in seconds.\n\n\nh::Vector{Real}=collect(0.0:20.0:1000.0)\n: offset vector; \nh[1:nh]\n.\n\n\nhref::Real=0.0\n: reference offset for parabolic Radon Transform. If the\n\n\n\n\ndefautl value \nhref=0.0\n is given, \nhref\n is set to \nmax(abs(h))\n.\n\n\n\n\np::Vector{Real}=collect(-0.05:0.01:2.2)\n: \np[1:np]\n. If \norder=\"parab\"\n, \np\n\n\n\n\nis a vector of residual moveout (\"curvatures\") at reference offset \nhref\n in seconds; if \norder=linear\n, \np\n is a vector of ray parameters in s/m.\n\n\n\n\nflow::Real=0.0\n: minimum frequency in the data in Hz.\n\n\nfhigh::Real=125.0\n: maximum frequency in the data in Hz.\n\n\n\n\nOutput\n\n\n\n\nd\n: data synthetized via forward Radon modeling, \nd[1:nt, 1:nh]\n.\n\n\n\n\nReferences\n\n\n\n\nHampson, D., 1986, Inverse velocity stacking for multiple elimination:\n\n\n\n\nCanadian Journal of Exploration Geophysics, 22, 44-55.\n\n\n\n\nSacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and\n\n\n\n\noffset space reconstruction: Geophysics, 60, 1169-1177.\n\n\nsource\n\n\n\n\nSeisRadonFreqInv\n\n\n#\n\n\nSeismic.SeisRadonFreqInv\n \n \nFunction\n.\n\n\nSeisRadonFreqInv(d; \nkeyword arguments\n)\n\n\n\n\n\nTransform a CMP Gather time-offset gather to tau-p gather using a frequency domain inverse parabolic or linear Radon operator via least-squares inversion.\n\n\nArguments\n\n\n\n\nd::Array{T\n:Real,2}\n: 2D data, \nd[1:nt,1:nh]\n, where \nnt\n is number of\n\n\n\n\ntime samples and \nnh\n the number of receivers.\n\n\nKeyword arguments\n\n\n\n\norder::AbstractString=\"parab\"\n: \n\"parab\"\n for parabolic transform, \n\"linear\"\n\n\n\n\nfor linear transform.\n\n\n\n\ndt::Real=0.004\n: sampling interval in seconds.\n\n\nh::Vector{Real}=collect(0.0:20.0:1000.0)\n: offset vector \nh[1:nh]\n.\n\n\nhref::Real=0.0\n: reference offset for parabolic Radon Transform. If the\n\n\n\n\ndefautl value \nhref=0.0\n is given, \nhref\n is set to \nmax(abs(h))\n.\n\n\n\n\np::Vector{Real}=collect(-0.05:0.01:2.2)\n: \np[1:np]\n. If \norder=\"parab\"\n, \np\n\n\n\n\nis a vector of residual moveout (\"curvatures\") at reference offset \nhref\n in seconds; if \norder=linear\n, \np\n is a vector of ray parameters in s/m.\n\n\n\n\nflow::Real=0.0\n: minimum frequency in the data in Hz.\n\n\nfhigh::Real=125.0\n: maximum frequency in the data in Hz.\n\n\nmu::Real=0.001\n: trade off parameter or damping for the L.S. inversion.\n\n\n\n\nOutput\n\n\n\n\nm\n: inverted Radon panel \nm[1:ntau, 1:np]\n.\n\n\n\n\nReferences\n\n\n\n\nHampson, D., 1986, Inverse velocity stacking for multiple elimination:\n\n\n\n\nCanadian Journal of Exploration Geophysics, 22, 44-55.\n\n\n\n\nSacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and\n\n\n\n\noffset space reconstruction: Geophysics, 60, 1169-1177.\n\n\nsource", 
            "title": "Processing"
        }, 
        {
            "location": "/Processing/page1/#processing", 
            "text": "", 
            "title": "Processing"
        }, 
        {
            "location": "/Processing/page1/#seisbandpass", 
            "text": "#  Seismic.SeisBandPass     Function .  SeisBandPass(d ;  keyword arguments )  Apply a bandpass filter to a 2D array input. Input and output data is in tx domain. Filter is applied in fx domain.  Arguments   d : Input 2D data array in tx domain.   Keyword arguments   dt=0.001 : time sampling interval.  fa=0,fb=0,fc=60,fd=80 : corner frequencies in Hz.   Output   d : Filtered 2d data arrayn in tx domain.   Example  ```julia julia  d = SeisLinearEvents(d); SeisPlot(d,plot_type=\"Amplitude\",dy=0.004,fmax=125); julia  d_filter = SeisBandPass(d;dt=0.004,fc=15,fd=35); SeisPlot(d_filter,plot_type=\"Amplitude\",dy=0.004,fmax=125);  source", 
            "title": "SeisBandPass"
        }, 
        {
            "location": "/Processing/page1/#seisdecimate", 
            "text": "#  Seismic.SeisDecimate     Function .  SeisDecimate(d ;  keyword arguments )  Decimate a multidimensional array input. Input and output have the same dimension  Arguments   d : Input data. Between 2D and 5D   Keyword arguments   mode=random : Data is decimated randomly. Otherwise it is regularly decimated.  perc=50 : percentage of traces to be decimated from original array  incx1=1,incx2=1,incx3=1,incx4=1 : traces to decimate in case of regular decimation   Output   out : Decimated data.   Example  ```julia julia  d = SeisLinearEvents(d); SeisPlot(d) julia  d_dec = SeisDecimate(d); SeisPlot(d_dec)  source", 
            "title": "SeisDecimate"
        }, 
        {
            "location": "/Processing/page1/#seisdelay", 
            "text": "#  Seismic.SeisDelay     Function .  SeisDelay(d ;  keyword arguments )  Apply a time delay to a 2D array input.   Arguments   d : Input 2D data array in tx domain.   Keyword arguments   delay=0.1 : time delay in seconds.  dt=0.001 : time sampling   Output   d2 : Delayed data in time domain   Example  ```julia julia  d = SeisLinearEvents(d); SeisPlot(d); julia  d2 = SeisDelay(d;dt=0.004); SeisPlot(d);  source", 
            "title": "SeisDelay"
        }, 
        {
            "location": "/Processing/page1/#seisenvelope", 
            "text": "#  Seismic.SeisEnvelope     Function .  SeisEnvelope(d)  Calculate the envelope attribute of an input trace  Arguments   d : Input data.   Output   out : Envelope of input data   Example  ```julia julia  d = SeisLinearEvents(d); SeisPlot(d) julia  out = SeisEnvelope(d); SeisPlot(d_dec)  source", 
            "title": "SeisEnvelope"
        }, 
        {
            "location": "/Processing/page1/#seisfkfilter", 
            "text": "#  Seismic.SeisFKFilter     Function .  SeisFKFilter(d ;  keyword arguments )  Decimate a multidimensional array input. Input and output have the same dimension  Arguments   d : 2D Input data.   Keyword arguments   dt=0.002 : time sampling interval.  dx=10 : space sampling interval.  va=-2000,vb=-3000,vc=3000,vd=2000 : corner velocities to be filtered   Output   out : Filtered data.   source", 
            "title": "SeisFKFilter"
        }, 
        {
            "location": "/Processing/page1/#seisgain", 
            "text": "#  Seismic.SeisGain     Function .  SeisGain(d, t;  keyword arguments )  Gain a group of traces.  Arguments   d::Array{Real,2} : two dimensional data.   Keyword arguments   dt::Real=0.002 : sampling interval in secs.  kind::AbstractString=\"time\" : if kind=\"time\", gain = t.^a . * exp(-bt);                        if kind=\"agc\", automatic gain control is applied.  param::Vector{Real}=[2.0,0.0] : if kind=\"time\", param = [a,b];                                  if kind=\"agc\", param = [agc_gate]  norm::Int=0 :  norm=0  no normalization;  norm=1  normalize each trace by                 amplitude;  norm=2  normalize each trace by rms value/   Output   d::Array{Real, 2}`: gained two dimensional data.   Example  julia   d ,   extent   =   SeisHypEvents (); \n        dout   =   SeisGain ( d ,   kind = agc ,   param = [ 0.05 ]); \n        SeisPlot ([ d   dout ],   extent );   Credits: Juan I. Sabbione, Aaron Staton, Mauricio D. Sacchi, 2016  source", 
            "title": "SeisGain"
        }, 
        {
            "location": "/Processing/page1/#seiskolmogoroff", 
            "text": "#  Seismic.SeisKolmogoroff     Function .  SeisKolmogoroff(w)  Kolmogoroff factorization. Transform a wavelet into its minimum phase equivalent.  Arguments   w::Real : input wavelet.   Example  julia   w   =   Ricker ()  julia   wmin   =   SeisKolmogoroff ( w )  julia   plot ( w );   plot ( wmin )   Reference   Claerbout, Jon F., 1976, Fundamentals of geophysical data processing.   McGraw-Hill Inc.  source", 
            "title": "SeisKolmogoroff"
        }, 
        {
            "location": "/Processing/page1/#seismwni", 
            "text": "#  Seismic.SeisMWNI     Function .  SeisMWNI  Minimum Weighted Norm Interpolation of seismic records.  IN       d_in: input data that can have up to 5 dimensions  dt=0.001 sampling rate along the time axis (in seconds)  fmax=99999. maximum temporal frequency to process.  padt=2 padding to use for the time axis  padx=1 padding to use for the spatial axes  Niter_internal=10 number of internal iterations for Conjugate Gradients  Niter_external=3 number of external iterations for iterative reweighting   OUT      d_out: interpolated data   source", 
            "title": "SeisMWNI"
        }, 
        {
            "location": "/Processing/page1/#seispocs", 
            "text": "#  Seismic.SeisPOCS     Function .  SeisPOCS  Projection Onto Convex Sets interpolation of seismic records.  IN   d_in: input data that can have up to 5 dimensions  p=1., exponent for thresholding (1 is equivalent to soft thres. high number is equivalent to hard thresholding)  alpha=1 add-back ratio for imputation step. Use 1 for noise free data, and   1 for denoising of original traces.  dt=0.001 sampling rate along the time axis (in seconds)  fmax=99999. maximum temporal frequency to process.  padt=2 padding to use for the time axis  padx=1 padding to use for the spatial axes  Niter=100 number of iterations   OUT   d_out: interpolated data   source", 
            "title": "SeisPOCS"
        }, 
        {
            "location": "/Processing/page1/#seisradonfreqfor", 
            "text": "#  Seismic.SeisRadonFreqFor     Function .  SeisRadonFreqFor(m, nt;  keyword arguments )  Transform a tau-p gather to a time-offset gather using a frequency domain forward parabolic or linear Radon operator.  Arguments   m::Array{T :Real,2} : 2D Radon panel,  m[1:ntau,1:np] , where  ntau  is the   number of intercept times and  np  the number of curvatures or ray parameters.   nt::Int : number of time samples in the data domain.   Keyword arguments   order::AbstractString=\"parab\" :  \"parab\"  for parabolic transform,  \"linear\"   for linear transform.   dt::Real=0.004 : sampling interval in seconds.  h::Vector{Real}=collect(0.0:20.0:1000.0) : offset vector;  h[1:nh] .  href::Real=0.0 : reference offset for parabolic Radon Transform. If the   defautl value  href=0.0  is given,  href  is set to  max(abs(h)) .   p::Vector{Real}=collect(-0.05:0.01:2.2) :  p[1:np] . If  order=\"parab\" ,  p   is a vector of residual moveout (\"curvatures\") at reference offset  href  in seconds; if  order=linear ,  p  is a vector of ray parameters in s/m.   flow::Real=0.0 : minimum frequency in the data in Hz.  fhigh::Real=125.0 : maximum frequency in the data in Hz.   Output   d : data synthetized via forward Radon modeling,  d[1:nt, 1:nh] .   References   Hampson, D., 1986, Inverse velocity stacking for multiple elimination:   Canadian Journal of Exploration Geophysics, 22, 44-55.   Sacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and   offset space reconstruction: Geophysics, 60, 1169-1177.  source", 
            "title": "SeisRadonFreqFor"
        }, 
        {
            "location": "/Processing/page1/#seisradonfreqinv", 
            "text": "#  Seismic.SeisRadonFreqInv     Function .  SeisRadonFreqInv(d;  keyword arguments )  Transform a CMP Gather time-offset gather to tau-p gather using a frequency domain inverse parabolic or linear Radon operator via least-squares inversion.  Arguments   d::Array{T :Real,2} : 2D data,  d[1:nt,1:nh] , where  nt  is number of   time samples and  nh  the number of receivers.  Keyword arguments   order::AbstractString=\"parab\" :  \"parab\"  for parabolic transform,  \"linear\"   for linear transform.   dt::Real=0.004 : sampling interval in seconds.  h::Vector{Real}=collect(0.0:20.0:1000.0) : offset vector  h[1:nh] .  href::Real=0.0 : reference offset for parabolic Radon Transform. If the   defautl value  href=0.0  is given,  href  is set to  max(abs(h)) .   p::Vector{Real}=collect(-0.05:0.01:2.2) :  p[1:np] . If  order=\"parab\" ,  p   is a vector of residual moveout (\"curvatures\") at reference offset  href  in seconds; if  order=linear ,  p  is a vector of ray parameters in s/m.   flow::Real=0.0 : minimum frequency in the data in Hz.  fhigh::Real=125.0 : maximum frequency in the data in Hz.  mu::Real=0.001 : trade off parameter or damping for the L.S. inversion.   Output   m : inverted Radon panel  m[1:ntau, 1:np] .   References   Hampson, D., 1986, Inverse velocity stacking for multiple elimination:   Canadian Journal of Exploration Geophysics, 22, 44-55.   Sacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and   offset space reconstruction: Geophysics, 60, 1169-1177.  source", 
            "title": "SeisRadonFreqInv"
        }, 
        {
            "location": "/ReadWrite/page1/", 
            "text": "ReadWrite\n\n\nSeismic.jl provides seismic data reading, writing and plotting. Currently, The conversions between SEIS data format and SEGY, SU and madagascar data format, bellow we give a simple example about converting SEGY data format to our internal data format.\n\n\n\n\nExample\n\n\n@example\nusing PyPlot, Seismic,Compat\ndownload(\"http://seismic.physics.ualberta.ca/data/gom_cdp_nmo.su\",\"gom_cdp_nmo.su\");\nSegyToSeis(\"gom_cdp_nmo.su\",\"gom_cdp_nmo\",format=\"su\",input_type=\"ieee\",swap_bytes=true);\nd, h, ext = SeisRead(\"gom_cdp_nmo\");\nSeisPlot(d[:, 1:1000], cmap=\"PuOr\", wbox=9)\nsavefig(\"usgs.svg\"); nothing # hide\n\n\nIn the above example, we first download the data, then convert the data from SU data format to SEIS format, finally the data are plotted.", 
            "title": "ReadWrite"
        }, 
        {
            "location": "/ReadWrite/page1/#readwrite", 
            "text": "Seismic.jl provides seismic data reading, writing and plotting. Currently, The conversions between SEIS data format and SEGY, SU and madagascar data format, bellow we give a simple example about converting SEGY data format to our internal data format.", 
            "title": "ReadWrite"
        }, 
        {
            "location": "/ReadWrite/page1/#example", 
            "text": "@example\nusing PyPlot, Seismic,Compat\ndownload(\"http://seismic.physics.ualberta.ca/data/gom_cdp_nmo.su\",\"gom_cdp_nmo.su\");\nSegyToSeis(\"gom_cdp_nmo.su\",\"gom_cdp_nmo\",format=\"su\",input_type=\"ieee\",swap_bytes=true);\nd, h, ext = SeisRead(\"gom_cdp_nmo\");\nSeisPlot(d[:, 1:1000], cmap=\"PuOr\", wbox=9)\nsavefig(\"usgs.svg\"); nothing # hide  In the above example, we first download the data, then convert the data from SU data format to SEIS format, finally the data are plotted.", 
            "title": "Example"
        }, 
        {
            "location": "/Solvers/page1/", 
            "text": "Solvers", 
            "title": "Solvers"
        }, 
        {
            "location": "/Solvers/page1/#solvers", 
            "text": "", 
            "title": "Solvers"
        }, 
        {
            "location": "/Tools/page1/", 
            "text": "Tools\n\n\n\n\nMeasureSNR\n\n\n#\n\n\nSeismic.MeasureSNR\n \n \nFunction\n.\n\n\nMeasureSNR(signal, noisy; db=false)\n\n\n\n\n\nMeasure the signal-to-noise ratio between the clean input \nsignal\n and the contaminated input \nnoisy\n.\n\n\nArguments\n\n\n\n\nsignal::Array{Real, N}\n: N-dimensional clean signal. \nN\n must be \n= 5.\n\n\nnoisy::Array{Real, N}\n: N-dimensional noisy signal of same size as \nsignal\n.\n\n\n\n\nKeyword arguments\n\n\n\n\ndb::Bool=false\n: \ndb=false\n if the signal-to-noise ratio is measured by\n\n\n\n\namplitude, or \ndb=true\n if the signal-to-noise ratio is measure in dB.\n\n\nExample\n\n\njulia\n \nd\n,\n \nextent\n \n=\n \nSeisHypEvents\n();\n \ndnoisy\n \n=\n \nSeisAddNoise\n(\nd\n,\n \n2\n);\n \n\nMeasureSNR\n(\nd\n,\n \ndnoisy\n)\n\n\n\n\n\n\nsource\n\n\n\n\nPadFirstAxis\n\n\n#\n\n\nSeismic.PadFirstAxis\n \n \nFunction\n.\n\n\nPadFirstAxis(d, N1)\n\n\n\n\n\nZero-padding first axis of N-dimensional array \nd\n.\n\n\nArguments\n\n\n\n\nd::Array{Real, N}\n: N-dimensional data.\n\n\nN1::Int\n: total number of samples for the first axis of the zero-padded data.\n\n\n\n\nExamples\n\n\njulia\n \nw\n \n=\n \nRicker\n();\n \nwpad\n \n=\n \nPadFirstAxis\n(\nw\n,\n \n128\n);\n \nplot\n(\nw\n);\n \nplot\n(\nwpad\n+\n1.0\n)\n\n\n\njulia\n \nd\n,\n \next\n \n=\n \nSeisHypEvents\n();\n \ndpad\n \n=\n \nPadFirstAxis\n(\nd\n,\n \n512\n);\n\n\nSeisPlot\n(\nd\n);\n \nSeisPlot\n(\ndpad\n)\n\n\n\n\n\n\nsource", 
            "title": "Tools"
        }, 
        {
            "location": "/Tools/page1/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/Tools/page1/#measuresnr", 
            "text": "#  Seismic.MeasureSNR     Function .  MeasureSNR(signal, noisy; db=false)  Measure the signal-to-noise ratio between the clean input  signal  and the contaminated input  noisy .  Arguments   signal::Array{Real, N} : N-dimensional clean signal.  N  must be  = 5.  noisy::Array{Real, N} : N-dimensional noisy signal of same size as  signal .   Keyword arguments   db::Bool=false :  db=false  if the signal-to-noise ratio is measured by   amplitude, or  db=true  if the signal-to-noise ratio is measure in dB.  Example  julia   d ,   extent   =   SeisHypEvents ();   dnoisy   =   SeisAddNoise ( d ,   2 );   MeasureSNR ( d ,   dnoisy )   source", 
            "title": "MeasureSNR"
        }, 
        {
            "location": "/Tools/page1/#padfirstaxis", 
            "text": "#  Seismic.PadFirstAxis     Function .  PadFirstAxis(d, N1)  Zero-padding first axis of N-dimensional array  d .  Arguments   d::Array{Real, N} : N-dimensional data.  N1::Int : total number of samples for the first axis of the zero-padded data.   Examples  julia   w   =   Ricker ();   wpad   =   PadFirstAxis ( w ,   128 );   plot ( w );   plot ( wpad + 1.0 )  julia   d ,   ext   =   SeisHypEvents ();   dpad   =   PadFirstAxis ( d ,   512 );  SeisPlot ( d );   SeisPlot ( dpad )   source", 
            "title": "PadFirstAxis"
        }, 
        {
            "location": "/Utils/page1/", 
            "text": "Utils\n\n\nSeismic.jl provides tools to work with real data sets like binning, patching, unpatching, data sorting and windowing. \n\n\n\n\nSeisGeometry\n\n\n#\n\n\nSeismic.SeisGeometry\n \n \nFunction\n.\n\n\nSeisGeometry(in;\nkeyword arguments\n)\n\n\n\n\n\nUpdate headers with geometry information. Offsets and azimuths are calculated from source and receivers coordinates. \n\n\nArguments\n\n\n\n\nin\n: input filename\n\n\n\n\nKeyword arguments\n\n\n\n\nang=90\n: inline direction measured in degrees CC from East\n\n\ngamma=1\n: vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)\n\n\nosx=0\n,\nosy=0\n,\nogx=0\n,\nogy=0\n : origin for source and receiver coordinate system\n\n\nomx=0\n,\nomy=0\n,\nohx=0\n,\nohy=0\n: origin for midpoint and offset coordinate system\n\n\noaz=0\n,\noh=0\n : origin for azimuth and offset coordinate system\n\n\ndsx=1\n,\ndsy=1\n,\ndgx=1\n,\ndgy=1\n: source and receiver step-size\n\n\ndmx=1\n,\ndmy=1\n,\ndhx=1\n,\ndhy=1\n: midpoint and offset step-size\n\n\ndh=1\n,\ndaz=1\n: offset and azimuth step-size\n\n\n\n\nOutputs\n\n\nthe .seish file is updated with the following information:\n\n\n\n\nhx,hy,h,az,mx,my : calculated offset, azimuth and midpoint\n\n\nisx,isy,igx,igy,imx,imy,ihx,ihy,ih,iaz: calculated grid nodes for source and receiver position and midpoint, offset and azimuth.\n\n\n\n\nCredits: A. Stanton, 2017\n\n\nsource\n\n\nSeisBinHeaders\n\n\n#\n\n\nSeismic.SeisBinHeaders\n \n \nFunction\n.\n\n\nSeisBinHeaders(in,out; \nkeyword arguments\n)\n\n\n\n\n\nSequentially bin seismic headers using the available grid information.\n\n\nKeyword arguments should be consistent with SeisGeometry keyword arguments.\n\n\nArguments\n\n\n\n\nin\n: filename of input, irregularly sampled data\n\n\nout\n: filename of output, regularly sampled data\n\n\n\n\nKeyword arguments\n\n\n\n\nstyle=\"sxsygxgy\"\n: bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"\n\n\nang=90\n: inline direction measured in degrees CC from East\n\n\ngamma=1\n: vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)\n\n\nosx=0\n,\nosy=0\n,\nogx=0\n,\nogy=0\n : origin for source and receiver coordinate system\n\n\nomx=0\n,\nomy=0\n,\nohx=0\n,\nohy=0\n: origin for midpoint and offset coordinate system\n\n\noaz=0\n,\noh=0\n : origin for azimuth and offset coordinate system\n\n\ndsx=1\n,\ndsy=1\n,\ndgx=1\n,\ndgy=1\n: source and receiver step-size\n\n\ndmx=1\n,\ndmy=1\n,\ndhx=1\n,\ndhy=1\n: midpoint and offset step-size\n\n\ndh=1\n,\ndaz=1\n: offset and azimuth step-size\n\n\nmin_isx=0\n,\nmax_isx=0\n,\nmin_isy=0\n,\nmax_isy=0\n: grid extreme values for sources\n\n\nmin_igx=0\n,\nmax_igx=0\n,\nmin_igy=0\n,\nmax_igy=0\n: grid extreme values for receivers\n\n\nmin_imx=0\n,\nmax_imx=0\n,\nmin_imy=0\n,\nmax_imy=0\n: grid extreme values for midpoints\n\n\nmin_ihx=0\n,\nmax_ihx=0\n,\nmin_ihy=0\n,\nmax_ihy=0\n: grid extreme values for offsets\n\n\nmin_ih=0\n,\nmax_ih=0\n,\nmin_iaz=0\n,\nmax_iaz=0\n: grid extreme values for azimuth and offset\n\n\nntrace=10000\n: maximum number of traces processed at a time\n\n\n\n\nOutput\n\n\nIn file \nout\n, binned headers are created.\n\n\nCredits: Aaron Stanton,2017\n\n\nsource\n\n\nSeisBinData\n\n\n#\n\n\nSeismic.SeisBinData\n \n \nFunction\n.\n\n\nSeisBinData(in,out; \nkeyword arguments\n)\n\n\n\n\n\nSequentially bin seismic data using already binned trace headers (SeisBinHeaders). Input arguments should be consistent with SeisBinHeaders input arguments.\n\n\nArguments\n\n\n\n\nin::AbstractString\n: filename of input, irregularly sampled data\n\n\nout::AbstractString\n: filename of output, regularly sampled data\n\n\n\n\nKeyword arguments\n\n\n\n\nstyle=\"sxsygxgy\"\n: bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"\n\n\nang=90\n: inline direction measured in degrees CC from East\n\n\ngamma=1\n: vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)\n\n\nosx=0\n,\nosy=0\n,\nogx=0\n,\nogy=0\n : origin for source and receiver coordinate system\n\n\nomx=0\n,\nomy=0\n,\nohx=0\n,\nohy=0\n: origin for midpoint and offset coordinate system\n\n\noaz=0\n,\noh=0\n : origin for azimuth and offset coordinate system\n\n\ndsx=1\n,\ndsy=1\n,\ndgx=1\n,\ndgy=1\n: source and receiver step-size\n\n\ndmx=1\n,\ndmy=1\n,\ndhx=1\n,\ndhy=1\n: midpoint and offset step-size\n\n\ndh=1\n,\ndaz=1\n: offset and azimuth step-size\n\n\nmin_isx=0\n,\nmax_isx=0\n,\nmin_isy=0\n,\nmax_isy=0\n: grid extreme values for sources\n\n\nmin_igx=0\n,\nmax_igx=0\n,\nmin_igy=0\n,\nmax_igy=0\n: grid extreme values for receivers\n\n\nmin_imx=0\n,\nmax_imx=0\n,\nmin_imy=0\n,\nmax_imy=0\n: grid extreme values for midpoints\n\n\nmin_ihx=0\n,\nmax_ihx=0\n,\nmin_ihy=0\n,\nmax_ihy=0\n: grid extreme values for offsets\n\n\nmin_ih=0\n,\nmax_ih=0\n,\nmin_iaz=0\n,\nmax_iaz=0\n: grid extreme values for azimuth and offset\n\n\nntrace=10000\n: maximum number of traces processed at a time\n\n\n\n\nOutput\n\n\nIn file \nout\n, the binned data is created.\n\n\nCredits: Aaron Stanton, 2017\n\n\nsource\n\n\nSeisPatch\n\n\n#\n\n\nSeismic.SeisPatch\n \n \nFunction\n.\n\n\n  \nSeisPatch\n(\nin\n::\nAbstractString\n,\nout\n::\nAbstractString\n;\nkeyword\n \narguments\n)\n\n\n\n\n\n\nCreates overlapping 5d patches from a 5d volume\n\n\nArguments\n\n\n\n\nin::AbstractString\n: input filename (data should have grid information in headers)\n\n\nout::AbstractString\n: prefix for output filenames\n\n\n\n\nKeyword arguments\n\n\n\n\nstyle=\"sxsygxgy\"\n: bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"\n\n\nmin_isx=0\n,\nmax_isx=0\n,\nmin_isy=0\n,\nmax_isy=0\n: grid extreme values for sources\n\n\nmin_igx=0\n,\nmax_igx=0\n,\nmin_igy=0\n,\nmax_igy=0\n: grid extreme values for receivers\n\n\nmin_imx=0\n,\nmax_imx=0\n,\nmin_imy=0\n,\nmax_imy=0\n: grid extreme values for midpoints\n\n\nmin_ihx=0\n,\nmax_ihx=0\n,\nmin_ihy=0\n,\nmax_ihy=0\n: grid extreme values for offsets\n\n\nmin_ih=0\n,\nmax_ih=0\n,\nmin_iaz=0\n,\nmax_iaz=0\n: grid extreme values for azimuth and offset\n\n\nit_WL=9e9\n,\nit_WO=0\n : length and overlapping samples in time patches\n\n\nix1_WL=9e9\n,\nix1_WO=0\n:length and overlapping samples in first space dimension\n\n\nix2_WL=9e9\n,\nix2_WO=0\n,\nix3_WL=9e9\n,\nix3_WO=0\n,\nix4_WL=9e9\n,\nix4_WO=0\n\n\n\n\nOutput\n\n\nfilename,npatch\n: AbstractString Array with the file name of the data patches, number of patches created\n\n\nCredits: A. Stanton, F. Carozzi, 2017\n\n\nsource\n\n\nSeisUnPatch\n\n\n#\n\n\nSeismic.SeisUnPatch\n \n \nFunction\n.\n\n\nSeisUnPatch(in,out;\nkeyword arguments\n)\n\n\n\n\n\nReconstruct a 5D data volume from a set of 5D data patches.\n\n\nArguments\n\n\n\n\nin::Array{AbstractString,1}\n: array containing filename of patches\n\n\nout::AbstractString\n: filename for reconstructed volume\n\n\n\n\nKeyword arguments\n\n\n\n\nstyle=\"sxsygxgy\"\n: bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"\n\n\nmin_isx=0\n,\nmax_isx=0\n,\nmin_isy=0\n,\nmax_isy=0\n: grid extreme values for sources\n\n\nmin_igx=0\n,\nmax_igx=0\n,\nmin_igy=0\n,\nmax_igy=0\n: grid extreme values for receivers\n\n\nmin_imx=0\n,\nmax_imx=0\n,\nmin_imy=0\n,\nmax_imy=0\n: grid extreme values for midpoints\n\n\nmin_ihx=0\n,\nmax_ihx=0\n,\nmin_ihy=0\n,\nmax_ihy=0\n: grid extreme values for offsets\n\n\nmin_ih=0\n,\nmax_ih=0\n,\nmin_iaz=0\n,\nmax_iaz=0\n: grid extreme values for azimuth and offset\n\n\nit_WL=9e9\n,\nit_WO=0\n : length and overlapping samples in time patches\n\n\nix1_WL=9e9\n,\nix1_WO=0\n:length and overlapping samples in first space dimension\n\n\nix2_WL=9e9\n,\nix2_WO=0\n,\nix3_WL=9e9\n,\nix3_WO=0\n,\nix4_WL=9e9\n,\nix4_WO=0\n\n\nnt=0\n: time samples of reconstructed cube\n\n\nang=90\n: inline direction measured in degrees CC from East\n\n\ngamma=1\n: vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)\n\n\nosx=0\n,\nosy=0\n,\nogx=0\n,\nogy=0\n : origin for source and receiver coordinate system\n\n\nomx=0\n,\nomy=0\n,\nohx=0\n,\nohy=0\n: origin for midpoint and offset coordinate system\n\n\noaz=0\n,\noh=0\n : origin for azimuth and offset coordinate system\n\n\ndsx=1\n,\ndsy=1\n,\ndgx=1\n,\ndgy=1\n: source and receiver step-size\n\n\ndmx=1\n,\ndmy=1\n,\ndhx=1\n,\ndhy=1\n: midpoint and offset step-size\n\n\ndh=1\n,\ndaz=1\n: offset and azimuth step-size\n\n\n\n\nOutput\n\n\nIn file \nout\n, the 5D reconstructed volume is created.\n\n\nCredits: A. Stanton, F Carozzi, 2017\n\n\nsource\n\n\nSeisSort\n\n\n#\n\n\nSeismic.SeisSort\n \n \nFunction\n.\n\n\nSeisSort(in, out;\nkeyword arguments\n)\n\n\n\n\n\nSort a seis file using its header words\n\n\nArguments\n\n\n\n\nin\n: input filename \n a text file with information about data extent, data and header file names; a binary file containing data and a binary file containing headers.\n\n\nout\n: output filename\n\n\n\n\nKeyword arguments\n\n\n\n\nkey=[\"imx\",\"imy\"]\n\n\nrev=false\n : sort headers in decreasing order\n\n\nntrace=1000\n : number of traces to read at a time\n\n\n\n\nOutput\n\n\nfile \nout\n is created with data sorted.\n\n\nCredits: AS, 2015\n\n\nsource\n\n\nSeisWindow\n\n\n#\n\n\nSeismic.SeisWindow\n \n \nFunction\n.\n\n\nSeisWindow(in,out;\nkeyword arguments\n)\n\n\n\n\n\nWindow a seis file using header words.\n\n\nArguments\n\n\n\n\nin::AbstractString\n: filename of input\n\n\nout::AbstractString\n: filename of output\n\n\n\n\nKeyword arguments\n\n\n\n\nkey\n\n\nminval\n\n\nmaxval\n\n\n\n\nnote that windowing along the time axis is achieved by using the key \"t\".\n\n\nCredits: AS, 2015\n\n\nsource", 
            "title": "Utils"
        }, 
        {
            "location": "/Utils/page1/#utils", 
            "text": "Seismic.jl provides tools to work with real data sets like binning, patching, unpatching, data sorting and windowing.", 
            "title": "Utils"
        }, 
        {
            "location": "/Utils/page1/#seisgeometry", 
            "text": "#  Seismic.SeisGeometry     Function .  SeisGeometry(in; keyword arguments )  Update headers with geometry information. Offsets and azimuths are calculated from source and receivers coordinates.   Arguments   in : input filename   Keyword arguments   ang=90 : inline direction measured in degrees CC from East  gamma=1 : vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)  osx=0 , osy=0 , ogx=0 , ogy=0  : origin for source and receiver coordinate system  omx=0 , omy=0 , ohx=0 , ohy=0 : origin for midpoint and offset coordinate system  oaz=0 , oh=0  : origin for azimuth and offset coordinate system  dsx=1 , dsy=1 , dgx=1 , dgy=1 : source and receiver step-size  dmx=1 , dmy=1 , dhx=1 , dhy=1 : midpoint and offset step-size  dh=1 , daz=1 : offset and azimuth step-size   Outputs  the .seish file is updated with the following information:   hx,hy,h,az,mx,my : calculated offset, azimuth and midpoint  isx,isy,igx,igy,imx,imy,ihx,ihy,ih,iaz: calculated grid nodes for source and receiver position and midpoint, offset and azimuth.   Credits: A. Stanton, 2017  source", 
            "title": "SeisGeometry"
        }, 
        {
            "location": "/Utils/page1/#seisbinheaders", 
            "text": "#  Seismic.SeisBinHeaders     Function .  SeisBinHeaders(in,out;  keyword arguments )  Sequentially bin seismic headers using the available grid information.  Keyword arguments should be consistent with SeisGeometry keyword arguments.  Arguments   in : filename of input, irregularly sampled data  out : filename of output, regularly sampled data   Keyword arguments   style=\"sxsygxgy\" : bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"  ang=90 : inline direction measured in degrees CC from East  gamma=1 : vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)  osx=0 , osy=0 , ogx=0 , ogy=0  : origin for source and receiver coordinate system  omx=0 , omy=0 , ohx=0 , ohy=0 : origin for midpoint and offset coordinate system  oaz=0 , oh=0  : origin for azimuth and offset coordinate system  dsx=1 , dsy=1 , dgx=1 , dgy=1 : source and receiver step-size  dmx=1 , dmy=1 , dhx=1 , dhy=1 : midpoint and offset step-size  dh=1 , daz=1 : offset and azimuth step-size  min_isx=0 , max_isx=0 , min_isy=0 , max_isy=0 : grid extreme values for sources  min_igx=0 , max_igx=0 , min_igy=0 , max_igy=0 : grid extreme values for receivers  min_imx=0 , max_imx=0 , min_imy=0 , max_imy=0 : grid extreme values for midpoints  min_ihx=0 , max_ihx=0 , min_ihy=0 , max_ihy=0 : grid extreme values for offsets  min_ih=0 , max_ih=0 , min_iaz=0 , max_iaz=0 : grid extreme values for azimuth and offset  ntrace=10000 : maximum number of traces processed at a time   Output  In file  out , binned headers are created.  Credits: Aaron Stanton,2017  source", 
            "title": "SeisBinHeaders"
        }, 
        {
            "location": "/Utils/page1/#seisbindata", 
            "text": "#  Seismic.SeisBinData     Function .  SeisBinData(in,out;  keyword arguments )  Sequentially bin seismic data using already binned trace headers (SeisBinHeaders). Input arguments should be consistent with SeisBinHeaders input arguments.  Arguments   in::AbstractString : filename of input, irregularly sampled data  out::AbstractString : filename of output, regularly sampled data   Keyword arguments   style=\"sxsygxgy\" : bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"  ang=90 : inline direction measured in degrees CC from East  gamma=1 : vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)  osx=0 , osy=0 , ogx=0 , ogy=0  : origin for source and receiver coordinate system  omx=0 , omy=0 , ohx=0 , ohy=0 : origin for midpoint and offset coordinate system  oaz=0 , oh=0  : origin for azimuth and offset coordinate system  dsx=1 , dsy=1 , dgx=1 , dgy=1 : source and receiver step-size  dmx=1 , dmy=1 , dhx=1 , dhy=1 : midpoint and offset step-size  dh=1 , daz=1 : offset and azimuth step-size  min_isx=0 , max_isx=0 , min_isy=0 , max_isy=0 : grid extreme values for sources  min_igx=0 , max_igx=0 , min_igy=0 , max_igy=0 : grid extreme values for receivers  min_imx=0 , max_imx=0 , min_imy=0 , max_imy=0 : grid extreme values for midpoints  min_ihx=0 , max_ihx=0 , min_ihy=0 , max_ihy=0 : grid extreme values for offsets  min_ih=0 , max_ih=0 , min_iaz=0 , max_iaz=0 : grid extreme values for azimuth and offset  ntrace=10000 : maximum number of traces processed at a time   Output  In file  out , the binned data is created.  Credits: Aaron Stanton, 2017  source", 
            "title": "SeisBinData"
        }, 
        {
            "location": "/Utils/page1/#seispatch", 
            "text": "#  Seismic.SeisPatch     Function .     SeisPatch ( in :: AbstractString , out :: AbstractString ; keyword   arguments )   Creates overlapping 5d patches from a 5d volume  Arguments   in::AbstractString : input filename (data should have grid information in headers)  out::AbstractString : prefix for output filenames   Keyword arguments   style=\"sxsygxgy\" : bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"  min_isx=0 , max_isx=0 , min_isy=0 , max_isy=0 : grid extreme values for sources  min_igx=0 , max_igx=0 , min_igy=0 , max_igy=0 : grid extreme values for receivers  min_imx=0 , max_imx=0 , min_imy=0 , max_imy=0 : grid extreme values for midpoints  min_ihx=0 , max_ihx=0 , min_ihy=0 , max_ihy=0 : grid extreme values for offsets  min_ih=0 , max_ih=0 , min_iaz=0 , max_iaz=0 : grid extreme values for azimuth and offset  it_WL=9e9 , it_WO=0  : length and overlapping samples in time patches  ix1_WL=9e9 , ix1_WO=0 :length and overlapping samples in first space dimension  ix2_WL=9e9 , ix2_WO=0 , ix3_WL=9e9 , ix3_WO=0 , ix4_WL=9e9 , ix4_WO=0   Output  filename,npatch : AbstractString Array with the file name of the data patches, number of patches created  Credits: A. Stanton, F. Carozzi, 2017  source", 
            "title": "SeisPatch"
        }, 
        {
            "location": "/Utils/page1/#seisunpatch", 
            "text": "#  Seismic.SeisUnPatch     Function .  SeisUnPatch(in,out; keyword arguments )  Reconstruct a 5D data volume from a set of 5D data patches.  Arguments   in::Array{AbstractString,1} : array containing filename of patches  out::AbstractString : filename for reconstructed volume   Keyword arguments   style=\"sxsygxgy\" : bin style. Options: \"mxmyhxhy\",\"mxmyhaz\",\"sxsyhxhy\",\"gxgyhxhy\",\"sxsyhaz\",\"gxgyhaz\"  min_isx=0 , max_isx=0 , min_isy=0 , max_isy=0 : grid extreme values for sources  min_igx=0 , max_igx=0 , min_igy=0 , max_igy=0 : grid extreme values for receivers  min_imx=0 , max_imx=0 , min_imy=0 , max_imy=0 : grid extreme values for midpoints  min_ihx=0 , max_ihx=0 , min_ihy=0 , max_ihy=0 : grid extreme values for offsets  min_ih=0 , max_ih=0 , min_iaz=0 , max_iaz=0 : grid extreme values for azimuth and offset  it_WL=9e9 , it_WO=0  : length and overlapping samples in time patches  ix1_WL=9e9 , ix1_WO=0 :length and overlapping samples in first space dimension  ix2_WL=9e9 , ix2_WO=0 , ix3_WL=9e9 , ix3_WO=0 , ix4_WL=9e9 , ix4_WO=0  nt=0 : time samples of reconstructed cube  ang=90 : inline direction measured in degrees CC from East  gamma=1 : vp/vs ratio for PS Asymptotic Conversion Point gathers (use gamma=1 for PP data)  osx=0 , osy=0 , ogx=0 , ogy=0  : origin for source and receiver coordinate system  omx=0 , omy=0 , ohx=0 , ohy=0 : origin for midpoint and offset coordinate system  oaz=0 , oh=0  : origin for azimuth and offset coordinate system  dsx=1 , dsy=1 , dgx=1 , dgy=1 : source and receiver step-size  dmx=1 , dmy=1 , dhx=1 , dhy=1 : midpoint and offset step-size  dh=1 , daz=1 : offset and azimuth step-size   Output  In file  out , the 5D reconstructed volume is created.  Credits: A. Stanton, F Carozzi, 2017  source", 
            "title": "SeisUnPatch"
        }, 
        {
            "location": "/Utils/page1/#seissort", 
            "text": "#  Seismic.SeisSort     Function .  SeisSort(in, out; keyword arguments )  Sort a seis file using its header words  Arguments   in : input filename   a text file with information about data extent, data and header file names; a binary file containing data and a binary file containing headers.  out : output filename   Keyword arguments   key=[\"imx\",\"imy\"]  rev=false  : sort headers in decreasing order  ntrace=1000  : number of traces to read at a time   Output  file  out  is created with data sorted.  Credits: AS, 2015  source", 
            "title": "SeisSort"
        }, 
        {
            "location": "/Utils/page1/#seiswindow", 
            "text": "#  Seismic.SeisWindow     Function .  SeisWindow(in,out; keyword arguments )  Window a seis file using header words.  Arguments   in::AbstractString : filename of input  out::AbstractString : filename of output   Keyword arguments   key  minval  maxval   note that windowing along the time axis is achieved by using the key \"t\".  Credits: AS, 2015  source", 
            "title": "SeisWindow"
        }, 
        {
            "location": "/Wavelets/page1/", 
            "text": "Wavelets\n\n\nA collection of seismic data processing wavelet\n\n\n\n\nBerlage\n\n\n#\n\n\nSeismic.Berlage\n \n \nFunction\n.\n\n\nBerlage(; \nkeyword arguments\n)\n\n\n\n\n\nCreate a Berlage wavelet.\n\n\nArguments\n\n\nKeyword arguments\n\n\n\n\ndt::Real=0.002\n: sampling interval in secs.\n\n\nf0::Real=20.0\n: central frequency in Hz.\n\n\nm::Real=2\n: exponential parameter of Berlage wavelet.\n\n\nalpha::Real=180.0\n: alpha parameter of Berlage wavelet in rad/secs.\n\n\nphi0::Real\n: phase rotation in radians.\n\n\n\n\nExample\n\n\njulia\n \nw\n \n=\n \nBerlage\n();\n \nplot\n(\nw\n);\n\n\n\n\n\n\nReference\n\n\n\n\nAldridge, David F., 1990, The berlage wavelet: GEOPHYSICS, 55, 1508\u20131511.\n\n\n\n\nsource\n\n\n\n\nOrmsby\n\n\n#\n\n\nSeismic.Ormsby\n \n \nFunction\n.\n\n\nOrmsby(; \nkeyword arguments\n)\n\n\n\n\n\nCreate a Ormsby wavelet sampled every dt seconds with corner frequencies defined by the vector f = [f1, f2, f3, f4]. The final wavelet is multiplied by a Hamming window.\n\n\nArguments\n\n\nKeyword arguments\n\n\n\n\ndt::Real=0.002\n: sampling interval in secs.\n\n\n\n\nf::Vector{Real}=[2.0, 10.0, 40.0, 60.0]\n: corner frequencies in Hz.\n\n\n^\n\n\n1 |     \n*\n*\n*     |    *               *     |   *                 *     |  *                   *     | *                     *     \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-\n f       f1  f2           f3  f4\n\n\n\n\n\n\nExample\n\n\njulia\n \nw\n \n=\n \nOrmsby\n();\n \nplot\n(\nw\n);\n\n\n\n\n\n\nsource\n\n\n\n\nRicker\n\n\n#\n\n\nSeismic.Ricker\n \n \nFunction\n.\n\n\nRicker(; \nkeyword arguments\n)\n\n\n\n\n\nCreate a Ricker wavelet.\n\n\nKeyword arguments\n\n\n\n\ndt::Real=0.002\n: sampling interval in secs.\n\n\nf0::Real=20.0\n: central frequency in Hz.\n\n\n\n\nExamples\n\n\njulia\n \nw\n \n=\n \nRicker\n();\n \nplot\n(\nw\n);\n\n\njulia\n \nw\n \n=\n \nRicker\n(\ndt\n=\n0.004\n,\n \nf0\n=\n20\n);\n \nplot\n(\nw\n);\n\n\n\n\n\n\nReference\n\n\nSheriff, Robert, 2002, Encyclopedic Dictionary of Applied Geophysics, fourth ed.: Society of Exploration Geophysicists. Geophysical Reference Series No. 13.\n\n\nsource", 
            "title": "Wavelets"
        }, 
        {
            "location": "/Wavelets/page1/#wavelets", 
            "text": "A collection of seismic data processing wavelet", 
            "title": "Wavelets"
        }, 
        {
            "location": "/Wavelets/page1/#berlage", 
            "text": "#  Seismic.Berlage     Function .  Berlage(;  keyword arguments )  Create a Berlage wavelet.  Arguments  Keyword arguments   dt::Real=0.002 : sampling interval in secs.  f0::Real=20.0 : central frequency in Hz.  m::Real=2 : exponential parameter of Berlage wavelet.  alpha::Real=180.0 : alpha parameter of Berlage wavelet in rad/secs.  phi0::Real : phase rotation in radians.   Example  julia   w   =   Berlage ();   plot ( w );   Reference   Aldridge, David F., 1990, The berlage wavelet: GEOPHYSICS, 55, 1508\u20131511.   source", 
            "title": "Berlage"
        }, 
        {
            "location": "/Wavelets/page1/#ormsby", 
            "text": "#  Seismic.Ormsby     Function .  Ormsby(;  keyword arguments )  Create a Ormsby wavelet sampled every dt seconds with corner frequencies defined by the vector f = [f1, f2, f3, f4]. The final wavelet is multiplied by a Hamming window.  Arguments  Keyword arguments   dt::Real=0.002 : sampling interval in secs.   f::Vector{Real}=[2.0, 10.0, 40.0, 60.0] : corner frequencies in Hz.  ^  1 |      * * *     |    *               *     |   *                 *     |  *                   *     | *                     *     \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-  f       f1  f2           f3  f4    Example  julia   w   =   Ormsby ();   plot ( w );   source", 
            "title": "Ormsby"
        }, 
        {
            "location": "/Wavelets/page1/#ricker", 
            "text": "#  Seismic.Ricker     Function .  Ricker(;  keyword arguments )  Create a Ricker wavelet.  Keyword arguments   dt::Real=0.002 : sampling interval in secs.  f0::Real=20.0 : central frequency in Hz.   Examples  julia   w   =   Ricker ();   plot ( w );  julia   w   =   Ricker ( dt = 0.004 ,   f0 = 20 );   plot ( w );   Reference  Sheriff, Robert, 2002, Encyclopedic Dictionary of Applied Geophysics, fourth ed.: Society of Exploration Geophysicists. Geophysical Reference Series No. 13.  source", 
            "title": "Ricker"
        }, 
        {
            "location": "/Windows/page1/", 
            "text": "Windows", 
            "title": "Windows"
        }, 
        {
            "location": "/Windows/page1/#windows", 
            "text": "", 
            "title": "Windows"
        }
    ]
}